#include "memorymap.h"
#include "tennis.h"
#include "smult.h"
#include "zeropage.h"

/* Coordinates and velocities are stored in 16 bit numbers in fixed-point
 * representation, where the upper 9 bits are before the fixed-point, and the
 * lower 7 bits are after the fixed-point
 */
static char ball_x_lo;
static char ball_x_hi;
static char ball_y_lo;
static char ball_y_hi;
char ball_vx_lo;
char ball_vx_hi;
char ball_vy_lo;
char ball_vy_hi;
static char ball_a11;
static char ball_a12;

// These two arrays contain the matrix ((A11, A12), (A12, -A11)),
// where A11 = ((y*y-x*x)*128)/(x*x+y*y)
// and   A12 = ((-2*x*y)*128)/(x*x+y*y)
// The values are stored as signed 8-bit numbers, i.e. in the range -128 to 127.
// The index into the arrays is 16x+y, where x and y are signed 4-bit
// numbers, i.e. -8<=x,y<=7.
static const unsigned char a11[256] = {
   0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
   0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
   0x80, 0x00, 0x4c, 0x66, 0x70, 0x76, 0x79, 0x7a,
   0x7c, 0x7a, 0x79, 0x76, 0x70, 0x66, 0x4c, 0x00,
   0x80, 0xb3, 0x00, 0x31, 0x4c, 0x5c, 0x66, 0x6c,
   0x70, 0x6c, 0x66, 0x5c, 0x4c, 0x31, 0x00, 0xb3,
   0x80, 0x9a, 0xcf, 0x00, 0x23, 0x3c, 0x4c, 0x58,
   0x60, 0x58, 0x4c, 0x3c, 0x23, 0x00, 0xcf, 0x9a,
   0x80, 0x8f, 0xb3, 0xdc, 0x00, 0x1c, 0x31, 0x40,
   0x4c, 0x40, 0x31, 0x1c, 0x00, 0xdc, 0xb3, 0x8f,
   0x80, 0x8a, 0xa3, 0xc4, 0xe4, 0x00, 0x17, 0x29,
   0x38, 0x29, 0x17, 0x00, 0xe4, 0xc4, 0xa3, 0x8a,
   0x80, 0x87, 0x9a, 0xb3, 0xcf, 0xe9, 0x00, 0x13,
   0x23, 0x13, 0x00, 0xe9, 0xcf, 0xb3, 0x9a, 0x87,
   0x80, 0x85, 0x93, 0xa8, 0xbf, 0xd6, 0xec, 0x00,
   0x10, 0x00, 0xec, 0xd6, 0xbf, 0xa8, 0x93, 0x85,
   0x80, 0x84, 0x8f, 0xa0, 0xb3, 0xc8, 0xdc, 0xef,
   0x00, 0xef, 0xdc, 0xc8, 0xb3, 0xa0, 0x8f, 0x84,
   0x80, 0x85, 0x93, 0xa8, 0xbf, 0xd6, 0xec, 0x00,
   0x10, 0x00, 0xec, 0xd6, 0xbf, 0xa8, 0x93, 0x85,
   0x80, 0x87, 0x9a, 0xb3, 0xcf, 0xe9, 0x00, 0x13,
   0x23, 0x13, 0x00, 0xe9, 0xcf, 0xb3, 0x9a, 0x87,
   0x80, 0x8a, 0xa3, 0xc4, 0xe4, 0x00, 0x17, 0x29,
   0x38, 0x29, 0x17, 0x00, 0xe4, 0xc4, 0xa3, 0x8a,
   0x80, 0x8f, 0xb3, 0xdc, 0x00, 0x1c, 0x31, 0x40,
   0x4c, 0x40, 0x31, 0x1c, 0x00, 0xdc, 0xb3, 0x8f,
   0x80, 0x9a, 0xcf, 0x00, 0x23, 0x3c, 0x4c, 0x58,
   0x60, 0x58, 0x4c, 0x3c, 0x23, 0x00, 0xcf, 0x9a,
   0x80, 0xb3, 0x00, 0x31, 0x4c, 0x5c, 0x66, 0x6c,
   0x70, 0x6c, 0x66, 0x5c, 0x4c, 0x31, 0x00, 0xb3,
   0x80, 0x00, 0x4c, 0x66, 0x70, 0x76, 0x79, 0x7a,
   0x7c, 0x7a, 0x79, 0x76, 0x70, 0x66, 0x4c, 0x00};

static const unsigned char a12[256] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x80, 0x9a, 0xb3, 0xc4, 0xcf, 0xd6, 0xdc,
   0x1f, 0x23, 0x29, 0x31, 0x3c, 0x4c, 0x66, 0x80,
   0x00, 0x9a, 0x80, 0x8a, 0x9a, 0xa8, 0xb3, 0xbc,
   0x3c, 0x43, 0x4c, 0x58, 0x66, 0x76, 0x80, 0x66,
   0x00, 0xb3, 0x8a, 0x80, 0x85, 0x8f, 0x9a, 0xa3,
   0x54, 0x5c, 0x66, 0x70, 0x7a, 0x80, 0x76, 0x4c,
   0x00, 0xc4, 0x9a, 0x85, 0x80, 0x83, 0x8a, 0x92,
   0x66, 0x6e, 0x76, 0x7c, 0x80, 0x7a, 0x66, 0x3c,
   0x00, 0xcf, 0xa8, 0x8f, 0x83, 0x80, 0x82, 0x87,
   0x73, 0x79, 0x7d, 0x80, 0x7c, 0x70, 0x58, 0x31,
   0x00, 0xd6, 0xb3, 0x9a, 0x8a, 0x82, 0x80, 0x82,
   0x7a, 0x7e, 0x80, 0x7d, 0x76, 0x66, 0x4c, 0x29,
   0x00, 0xdc, 0xbc, 0xa3, 0x92, 0x87, 0x82, 0x80,
   0x7e, 0x80, 0x7e, 0x79, 0x6e, 0x5c, 0x43, 0x23,
   0x00, 0x1f, 0x3c, 0x54, 0x66, 0x73, 0x7a, 0x7e,
   0x80, 0x81, 0x85, 0x8d, 0x9a, 0xac, 0xc4, 0xe0,
   0x00, 0x23, 0x43, 0x5c, 0x6e, 0x79, 0x7e, 0x80,
   0x81, 0x80, 0x82, 0x87, 0x92, 0xa3, 0xbc, 0xdc,
   0x00, 0x29, 0x4c, 0x66, 0x76, 0x7d, 0x80, 0x7e,
   0x85, 0x82, 0x80, 0x82, 0x8a, 0x9a, 0xb3, 0xd6,
   0x00, 0x31, 0x58, 0x70, 0x7c, 0x80, 0x7d, 0x79,
   0x8d, 0x87, 0x82, 0x80, 0x83, 0x8f, 0xa8, 0xcf,
   0x00, 0x3c, 0x66, 0x7a, 0x80, 0x7c, 0x76, 0x6e,
   0x9a, 0x92, 0x8a, 0x83, 0x80, 0x85, 0x9a, 0xc4,
   0x00, 0x4c, 0x76, 0x80, 0x7a, 0x70, 0x66, 0x5c,
   0xac, 0xa3, 0x9a, 0x8f, 0x85, 0x80, 0x8a, 0xb3,
   0x00, 0x66, 0x80, 0x76, 0x66, 0x58, 0x4c, 0x43,
   0xc4, 0xbc, 0xb3, 0xa8, 0x9a, 0x8a, 0x80, 0x9a,
   0x00, 0x80, 0x66, 0x4c, 0x3c, 0x31, 0x29, 0x23,
   0xe0, 0xdc, 0xd6, 0xcf, 0xc4, 0xb3, 0x9a, 0x80};

void __fastcall__ ball_reset(void)
{
   ball_x_hi  = WALL_XPOS/4-3;
   ball_x_lo  = 0;
   ball_y_hi  = WALL_YPOS/4;
   ball_y_lo  = 0;
   ball_vx_hi = 0;
   ball_vx_lo = 0;
   ball_vy_hi = 0;
   ball_vy_lo = 0x80;
} // end of ball_reset

// This function calculates w = A*v, i.e.
// wx = A11*vx + A12*vy and
// wy = A12*vx - A11*vy
//
// Input to this function is the matrix A, where
// A11 = -A22 and A12 = A21.
// So we must have A11 in 'A' and A12 in 'X'.
// A11 and A12 are signed 8-bit numbers, with seven bits after the fixed-point.
// vx and vy are signed 16-bit number, with 9 bits before the fixed-point.
static void __fastcall__ ball_rotate(void)
{
   __asm__("STA %v", ball_a11);
   __asm__("TXA");
   __asm__("STA %v", ball_a12);

   // X already contains A12
   __asm__("LDA %v", ball_vy_lo);
   __asm__("ROL A");
   __asm__("LDA %v", ball_vy_hi);
   __asm__("ROL A");
   smult();
   __asm__("STA %b", ZP_BALL_T0);
   __asm__("TXA");
   __asm__("STA %b", ZP_BALL_T1);

   // Move A11 to X
   __asm__("LDA %v", ball_a11);
   __asm__("TAX");
   __asm__("LDA %v", ball_vx_lo);
   __asm__("ROL A");
   __asm__("LDA %v", ball_vx_hi);
   __asm__("ROL A");
   smult();
   __asm__("ADC %b", ZP_BALL_T0);
   __asm__("STA %b", ZP_BALL_T0);
   __asm__("TXA");
   __asm__("ADC %b", ZP_BALL_T1);
   __asm__("STA %b", ZP_BALL_T1);

   // Move A11 to X
   __asm__("LDA %v", ball_a11);
   __asm__("TAX");
   __asm__("LDA %v", ball_vy_lo);
   __asm__("ROL A");
   __asm__("LDA %v", ball_vy_hi);
   __asm__("ROL A");
   smult();
   __asm__("STA %b", ZP_BALL_T2);
   __asm__("TXA");
   __asm__("STA %b", ZP_BALL_T3);

   // Move A12 to X
   __asm__("LDA %v", ball_a12);
   __asm__("TAX");
   __asm__("LDA %v", ball_vx_lo);
   __asm__("ROL A");
   __asm__("LDA %v", ball_vx_hi);
   __asm__("ROL A");
   smult();
   __asm__("SBC %b", ZP_BALL_T2);
   __asm__("STA %b", ZP_BALL_T2);
   __asm__("TXA");
   __asm__("SBC %b", ZP_BALL_T3);
   __asm__("STA %b", ZP_BALL_T3);

   __asm__("LDA %b", ZP_BALL_T3);
   __asm__("ROL A");  // Copy MSB to carry
   __asm__("LDA %b", ZP_BALL_T3);
   __asm__("ROR A");
   __asm__("STA %v", ball_vy_hi);
   __asm__("LDA %b", ZP_BALL_T2);
   __asm__("ROR A");
   __asm__("STA %v", ball_vy_lo);

   __asm__("LDA %b", ZP_BALL_T1);
   __asm__("ROL A");  // Copy MSB to carry
   __asm__("LDA %b", ZP_BALL_T1);
   __asm__("ROR A");
   __asm__("STA %v", ball_vx_hi);
   __asm__("LDA %b", ZP_BALL_T0);
   __asm__("ROR A");
   __asm__("STA %v", ball_vx_lo);

} // end of ball_rotate

// This functions bounces the ball on a player.
// Input is the players coordinates divided by two,
// i.e. 'X' = Px/2 and 'A' = Py/2
void __fastcall__ ball_bounce(void)
{
   // First we must calculate PB/2
   // We divide by two, so that the coordinates of PB/2 can be represented in
   // two 4-bit signed numbers. This is because |PB/2| < 8.

   __asm__("SEC");
   __asm__("EOR #$FF");
   __asm__("ADC %v", ball_y_hi); // This contains By/2.
   __asm__("AND #$0F");
   __asm__("STA %b", ZP_BALL_T1);

   __asm__("TXA");
   __asm__("SEC");
   __asm__("EOR #$FF");
   __asm__("ADC %v", ball_x_hi); // This contains Bx/2.

   __asm__("ASL A");
   __asm__("ASL A");
   __asm__("ASL A");
   __asm__("ASL A");
   __asm__("CLC");
   __asm__("ADC %b", ZP_BALL_T1);

   // Now look up the matrix elements A11 and A12
   __asm__("TAX");
   __asm__("LDA %v,X", a11);
   __asm__("TAY");
   __asm__("LDA %v,X", a12);
   __asm__("TAX");
   __asm__("TYA");

   // Now we have A11 in 'A' and A12 in 'X'.

   ball_rotate();

} // end of ball_bounce

void __fastcall__ ball_move(void)
{
   // Update velocity
   __asm__("LDA %v", ball_vy_lo);
   __asm__("CLC");
   __asm__("ADC #%b", GRAVITY);
   __asm__("STA %v", ball_vy_lo);
   __asm__("LDA %v", ball_vy_hi);
   __asm__("ADC #$00");
   __asm__("STA %v", ball_vy_hi);

   // Update position
   __asm__("LDA %v", ball_y_lo);
   __asm__("CLC");
   __asm__("ADC %v", ball_vy_lo);
   __asm__("STA %v", ball_y_lo);
   __asm__("LDA %v", ball_y_hi);
   __asm__("ADC %v", ball_vy_hi);
   __asm__("STA %v", ball_y_hi);

   __asm__("LDA %v", ball_x_lo);
   __asm__("CLC");
   __asm__("ADC %v", ball_vx_lo);
   __asm__("STA %v", ball_x_lo);
   __asm__("LDA %v", ball_x_hi);
   __asm__("ADC %v", ball_vx_hi);
   __asm__("STA %v", ball_x_hi);

   // Update VGA
   __asm__("LDA %v", ball_x_lo);
   __asm__("ROL A");
   __asm__("LDA %v", ball_x_hi);
   __asm__("ROL A");
   __asm__("STA %w", VGA_ADDR_SPRITE_0_X);
   __asm__("LDA #$00");
   __asm__("ROL A");
   __asm__("STA %w", VGA_ADDR_SPRITE_0_X_MSB);

   __asm__("LDA %v", ball_y_lo);
   __asm__("ROL A");
   __asm__("LDA %v", ball_y_hi);
   __asm__("ROL A");
   __asm__("STA %w", VGA_ADDR_SPRITE_0_Y);
} // end of ball_move


