# Design Your Own Computer
# Episode 4 : "Adding hexadecimal output to VGA"

Welcome to the fourth episode of "Design Your Own Computer". In this
episode we will be accomplishing several tasks:
* Adding a complete ASCII font to the system.
* Changing the VGA output to show data using hexadecimal digits.

## Adding a complete ASCII font
We will need to write more than just 0's and 1's on the screen. So I've found
a complete 8x8 pixel font at <https://github.com/dhepper/font8x8>.
The entire font will be stored in a memory (ROM) inside the FPGA, i.e.
it will be part of the bit file generated by the synthesis tool.

We will store the font in a separate file, instead of inside the source file
itself.  The synthesis tool supports initializing a memory from a file while
generating the bit file, but the data must be correctly formatted. Mainly, the
file must be a text file, where each line corresponds to one entry in the
memory.

In the current case we have 256 possible characters, so the memory will have
256 entries, where each entry is 8x8 = 64 bits wide. The font file will
therefore have 256 lines. The contents have been copied from the above link,
but the formatting has been changed to accomodate the synthesis tool.

Once again, to separate responsibilities, the memory containing the font is
moved to a new file vga/font.vhd.  The interface in lines 7-18 is similar to a
memory interface, except there are no signals to write to the memory, and there
is no clock input. This means this memory is entirely combinatorial, and the
synthesis tool can not used the built-in Block RAMs.  Lines 12-13 translate to
the address of the memory, and lines 15-16 translate to the contents of the
memory at the selected address. This will provide the bitmap associated with
the current character.

The command hread() in line 37 of vga/font.vbhd reads an entire line of
hexadecimal digits.

The file name containing the font is passed as a generic in line 9 of
vga/font.vhd.

Notice that line 51 in vga/font.vhd (reading the font data) is similar to line
60 in mem/mem.vhd (reading from memory). This is no coincidence, and by looking
at the interface of the font block, the character input can be regarded as a
memory address, and the bitmap output can be regarded as the memory data.  In a
later episode we'll make use of this similarity and implement the font data
into a RAM that the CPU can read from and write to. This will enable the program
running on the CPU to update the character font.

## Showing hexadecimal digits.

Lines 86-88 in vga/digits.vhd have changed to read four bits at a time from the
input data. This is because a single hexadecimal digit consists of four bits.

The ASCII code is calculated in lines 95-96.

Line 117 has been changed, because of the way the font is stored in the text
file.  In the previous episode, the MSB of the font data corresponded to the
left most pixel.  But in the font data copied from the above web page, the MSB
is the right most pixel.  To be consistent, the font data should be changed
(and that can easily be done by a small separate program), but I decided this
extra processing was annoying.

Line 136 has been changed, to reflect that there are now only six characters
displayed on the screen.

And that is it! We are now in a position where we can display data on the screen
in the form of hexadecimal digits. We are therefore ready to begin the first
steps in designing the CPU.

When running this bitfile you should see the 16 address bits count up, and the
8 data bits should reflect the memory contents at that memory address. The
speed of the counting can be controlled by the 8 slide switches.

## Learnings:
Initializing memory directly from a separate text file.

