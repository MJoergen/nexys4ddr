#include <6502.h>                // CLI()
#include <string.h>              // memmove
#include "memorymap.h"

// This holds a small buffer of keyboard events
#define KBD_BUFFER_SIZE 6
static uint8_t kbd_buffer[KBD_BUFFER_SIZE];
static uint8_t kbd_buffer_count = 0;

// Current state of keyboard
static uint8_t kbd_release = 0;  // A release event is being processed.
static uint8_t kbd_shifted = 0;  // A shift key is pressed.

#define KBD_SHIFT_LEFT  0x12
#define KBD_SHIFT_RIGHT 0x59
#define KBD_RELEASE     0xF0

static const uint8_t kbd_tab_normal[128] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x31, 0x00, 0x00, 0x00, 0x7A, 0x73, 0x61, 0x77, 0x32, 0x00,
   0x00, 0x63, 0x78, 0x64, 0x65, 0x34, 0x33, 0x00, 0x00, 0x20, 0x76, 0x66, 0x74, 0x72, 0x35, 0x00,
   0x00, 0x6E, 0x62, 0x68, 0x67, 0x79, 0x36, 0x00, 0x00, 0x00, 0x6D, 0x6A, 0x75, 0x37, 0x38, 0x00,
   0x00, 0x2C, 0x6B, 0x69, 0x6F, 0x30, 0x39, 0x00, 0x00, 0x2E, 0x2D, 0x6C, 0xE6, 0x70, 0x2B, 0x00,
   0x00, 0x00, 0xF8, 0x00, 0xE5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x7E, 0x00, 0x27, 0x00, 0x00,
   0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x03, 0x00, 0x1B, 0x02, 0x00, 0x00, 0x00,
   0x00, 0x7F, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t kbd_tab_shifted[128] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x21, 0x00, 0x00, 0x00, 0x5A, 0x53, 0x41, 0x57, 0x22, 0x00,
   0x00, 0x43, 0x58, 0x44, 0x45, 0x24, 0x23, 0x00, 0x00, 0x20, 0x56, 0x46, 0x54, 0x52, 0x25, 0x00,
   0x00, 0x4E, 0x42, 0x48, 0x47, 0x59, 0x26, 0x00, 0x00, 0x00, 0x4D, 0x4A, 0x55, 0x2F, 0x28, 0x00,
   0x00, 0x3B, 0x4B, 0x49, 0x4F, 0x3D, 0x29, 0x00, 0x00, 0x3A, 0x5F, 0x4C, 0xC6, 0x50, 0x3F, 0x00,
   0x00, 0x00, 0xD8, 0x00, 0xC5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x5E, 0x00, 0x2A, 0x00, 0x00,
   0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Private helper function
static uint8_t kbd_buffer_pop()
{
   uint8_t kbd_data;

   // Wait for keyboard event
   while (kbd_buffer_count == 0)
   {}

   SEI();
   kbd_data = kbd_buffer[0];
   memmove(kbd_buffer, kbd_buffer+1, kbd_buffer_count);
   kbd_buffer_count--;
   CLI();

   return kbd_data;
} // end of kbd_buffer_pop


// Keyboard interrupt
// This must be written entirely in assembler, because the C code is not re-entrant.
void kbd_isr()
{
   __asm__("LDA %w", (uint16_t) KBD_DATA);     // Read keyboard event into A.
   __asm__("LDX %v", kbd_buffer_count);
   __asm__("CPX #%b", KBD_BUFFER_SIZE);
   __asm__("BEQ %g", end_isr);          // Skip if keyboard buffer is full.

   __asm__("STA %v,X", kbd_buffer);
   __asm__("INC %v", kbd_buffer_count);

end_isr:
   __asm__("RTS");
} // end of kbd_isr

// Read keyboard event. Will wait in blocking mode.
uint8_t kbd_getchar()
{
   uint8_t kbd_data;

   while (1)
   {
      kbd_data = kbd_buffer_pop();    // This is a blocking call

      if (kbd_data == KBD_RELEASE)
      {
         kbd_release = 1;
         continue;
      }

      if (kbd_release)
      {
         if (kbd_data == KBD_SHIFT_LEFT || kbd_data == KBD_SHIFT_RIGHT)
            kbd_shifted = 0;
         kbd_release = 0;
         continue;
      }

      if (kbd_data == KBD_SHIFT_LEFT || kbd_data == KBD_SHIFT_RIGHT)
      {
         kbd_shifted = 1;
         continue;
      }

      // Only values with bit 7 clear are accepted.
      if (kbd_data >= 128)
      {
         continue;
      }

      // OK, nothing special going on.
      break;
   } // end of while (1)

   if (kbd_shifted)
      return kbd_tab_shifted[kbd_data];
   else
      return kbd_tab_normal[kbd_data];
} // end of kbd_getchar

//#include "../lib/vga.c"
