#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "memorymap.h"
#include "ethernet.h"

// This is the number of bytes to use for the entire receive buffer. It should be
// large enough to contain at least one complete frame, i.e. 1500 bytes.
#define BUF_SIZE 1540

// This variable is only used during simulation, to test the arbitration
// between CPU and Ethernet while writing to memory.
uint8_t dummy_counter = 0;

// Start of receive buffer
uint8_t *pBufStart;

// Current read pointer of the CPU
uint8_t *rdPtr;

// Length of current frame
uint16_t frmLen;

void main(void)
{
   // Allocate receive buffer. This will never be free'd.
   // Using malloc (rather than a globally allocated array) avoids a call to
   // memset generated by the compiler, thereby reducing simulation time.
   pBufStart = (uint8_t *) malloc(BUF_SIZE);
   rdPtr     = pBufStart;

   // Configure Ethernet DMA
   MEMIO_CONFIG->ethRxdmaEnable = 0;  // DMA must be disabled during configuration.
   MEMIO_CONFIG->ethRxdmaStart  = (uint16_t) pBufStart;
   MEMIO_CONFIG->ethRxdmaSize   = (uint16_t) BUF_SIZE;
   MEMIO_CONFIG->ethRxCpuPtr    = (uint16_t) rdPtr;
   MEMIO_CONFIG->ethRxdmaEnable = 1;  // Enabling the DMA will automatically reset the ethWrPtr.
 
   // Wait for data to be received, and print to the screen
   while (1)
   {
      // Wait until an ethernet frame has been received
      while (MEMIO_STATUS->ethRxbufSize == 0)
      {
         dummy_counter += 1;   // This generates a write to the main memory.
      }
      
      // Calculate length of frame
      frmLen = *((uint16_t *)rdPtr);  // Read as little-endian.

      processFrame(rdPtr+2, frmLen-2);

      // Release input buffer
      MEMIO_CONFIG->ethRxCpuPtr = (uint16_t) (rdPtr + frmLen);
      while (MEMIO_STATUS->ethRxbufSize != 0)
      { }
      MEMIO_CONFIG->ethRxCpuPtr = (uint16_t) pBufStart;
   }

} // end of main

