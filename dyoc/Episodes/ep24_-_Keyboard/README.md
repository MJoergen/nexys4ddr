# Design Your Own Computer
# Episode 24 : "Keyboard"
 
Welcome to "Design Your Own Computer".  In this episode we'll add the ability
to read key strokes from the keyboard, using the PS/2 interface.

## FPGA changes

### PS/2 interface
The PS/2 interface consists of a single clock line and a single data line. Both
clock and data are generated by the keyboard.

Data received on the PS/2 interface consists of 11 bits per byte: S01234567PT.
Here S is Start (always a '0'), P is parity (odd), and T is Stop (always a
'1').  In the FPGA, we wait for a falling edge on the PS/2 clock and shift the
data bit into a shift register.

After 11 bits, we can extract the byte from the shift register.  However, this
is not very robust, since if the FPGA should ever get out of synchronization,
it will forever remain out of synchronization. So we implement a simple state
machine that after the 11 bits checks the Start and Stop bits.  If they are not
correct, it will check after every bit, and wait for the correct values of the
Start and Stop bits. This is all controlled in lines 83-115 of
keyboard/ps2.vhd.

### Interrupt map
The PS/2 module generates an interrupt, whenever a keyboard event has been
received. This interrupt is connected to bit 2 of the Interrupt Controller,
see line 327 of fpga/comp.vhd.

### Memory map
The last keyboard event can be read from the address 7FE8, see line 315 of
fpga/comp.vhd.  There is no buffering in the FPGA, and therefore the keyboard
interrupt must be serviced reasonably quickly, especially since the keyboard
may generate several events back-to-back.

### VGA Overlay
I've added the last keyboard event to the VGA overlay, see line 336 of
fpga/comp.vhd.

## Software changes

### Startup code
The startup code in lib/crt0.s enables both timer interrupt and keyboard
interrupt as default, see line 62. The corresponding interrupt routine is
referenced in line of lib/irq.s, and is implemented in the new file
lib/kbd\_isr.s.

### Interrupt service routine
The interrupt routine manages a small buffer of keyboard events. If the buffer
is full, the new keyboard event is discarded.

### Access to keyboard buffer
I've added a function kbd\_buffer\_pop() in the file lib/keyboard.c that
returns the oldest keyboard event. If the buffer is empty, it will do a
blocking wait.

