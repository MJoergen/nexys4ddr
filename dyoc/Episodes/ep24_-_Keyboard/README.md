# Design Your Own Computer
# Episode 24 : "Keyboard"
 
Welcome to "Design Your Own Computer".  In this episode we'll add the ability
to read key strokes from the keyboard, using the PS/2 interface.

## FPGA changes

### PS/2 interface
The PS/2 interface consists of a single clock line and a single data line. Both
clock and data are generated by the keyboard.

Data received on the PS/2 interface consists of 11 bits per byte: S01234567PT.
Here S is Start (always a '0'), P is parity (odd), and T is Stop (always a
'1').  In the FPGA, we wait for a falling edge on the PS/2 clock and shift the
data bit into a shift register.

After 11 bits, we can extract the byte from the shift register.  However, this
is not very robust, since if the FPGA should ever get out of synchronization,
it will forever remain out of synchronization. So we implement a simple state
machine that after the 11 bits checks the Start and Stop bits.  If they are not
correct, it will check after every bit, and wait for the correct values of the
Start and Stop bits. This is all controlled in lines 83-115 of
keyboard/ps2.vhd.

### Keyboard scan codes
The data sent from the keyboard to the FPGA are called scan codes, and are
enturely different from ASCII values. Furthermore, pressing keys like shift and
control sends scan codes as well. The two shift keys have different scan codes
even! So there needs to be a mapping from scan code to ASCII code, as well as a
state machine to keep track of whether shift is pressed or not.

I've chosen to place this functionality in the FPGA (instead of in the software),
because the key tables alone take up 256 bytes. In the FPGA this lookup is
performed in the new file keyboard/scancode.vhd.

### Interrupt map
The PS/2 module generates an interrupt, whenever a keyboard event has been
received. This interrupt is connected to bit 2 of the Interrupt Controller,
see line 331 of fpga/comp.vhd.

### Memory map
The last keyboard event can be read from the address 7FE8, see line 319 of
fpga/comp.vhd.  There is no buffering in the FPGA, and therefore the keyboard
interrupt must be serviced reasonably quickly, especially since the keyboard
may generate several events back-to-back.

### VGA Overlay
I've added the last keyboard event to the VGA overlay, see line 340 of
fpga/comp.vhd.

### Cleanup
I've split the CPU datapath module into a number of separate files to make the
hierearchy more clear. Basically, the datapath module itself contains no
registers, only instantiated sub-blocks.

## Software changes

### Startup code
The startup code in lib/crt0.s enables both timer interrupt and keyboard
interrupt as default, see line 62. The corresponding interrupt routine is
referenced in line of lib/irq.s, and is implemented in the new file
lib/kbd\_isr.s.

### Interrupt service routine
The interrupt routine manages a small buffer of keyboard events. If the buffer
is full, the new keyboard strokes are ignored.

### Access to keyboard buffer
I've added a function cgetc() in the file lib/cgetc.c that
returns the oldest keyboard event. If the buffer is empty, it will do a
blocking wait.

Additionally, inputting a line is done by implementing the function read(),
which is a standard system call that takes three parameters: A file descriptor
and a buffer pointer and size. The function must return the number of
characters read.

