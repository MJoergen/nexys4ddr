#include <stdint.h>
#include <stdlib.h>
#include <conio.h>
#include "memorymap.h"

// This is the number of bytes to use for the entire receive buffer. It should be
// large enough to contain at least one complete frame, i.e. 1500 bytes.
#define BUF_SIZE 2000

// This macro reads a single byte from the buffer, while automatically
// taking care of wrap around.
// The end of the buffer must be in the variable 'pBufEnd', and
// the size of the buffer must be in 'BUF_SIZE'.
#define RD_BUF(ptr) ((ptr) < pBufEnd ? *(ptr) : *((ptr)-BUF_SIZE))

#define RD_BUF_OFFSET(ptr, offset) ((ptr)+(offset) < pBufEnd ? *((ptr)+(offset)) : *((ptr)+(offset)-BUF_SIZE))

// This macro increments the pointer by a given number of bytes, while
// automatically taking care of wrap around.
// The end of the buffer must be in the variable 'pBufEnd', and
// the size of the buffer must be in 'BUF_SIZE'.
#define ADD_PTR(ptr, inc) ((ptr)+(inc) < pBufEnd ? (ptr)+(inc) : (ptr) + (inc) - BUF_SIZE)

#if 1
// Write a single byte in hexadecimal.
void putx8(uint8_t x)
{
   static const char hex[16] = "0123456789ABCDEF";
   cputc(hex[(x>>4) & 0x0F]);
   cputc(hex[(x>>0) & 0x0F]);
}

// Write a 16-bit value in hexadecimal.
void putx16(uint16_t x)
{
   putx8((x>>8) & 0xFF);
   putx8((x>>0) & 0xFF);
}
#endif

void main(void)
{
   // This variable is only used during simulation, to test the arbitration
   // between CPU and Ethernet while writing to memory.
   uint8_t dummy_counter = 0;

   // Allocate receive buffer. This will never be free'd.
   // Using malloc (rather than a globally allocated array) avoids a call to
   // memset generated by the compiler, thereby reducing simulation time.
   uint8_t *pBuf = (uint8_t *) malloc(BUF_SIZE);

   // First byte after the buffer. This is used in the macro RD_BUF().
   uint8_t *pBufEnd = pBuf + BUF_SIZE;

   // Current read pointer of the CPU
   uint8_t *rdPtr = pBuf;

   // Configure Ethernet DMA
   MEMIO_CONFIG->ethEnable = 0;  // DMA must be disabled during configuration.
   MEMIO_CONFIG->ethStart  = (uint16_t) pBuf;
   MEMIO_CONFIG->ethEnd    = (uint16_t) pBufEnd;
   MEMIO_CONFIG->ethRdPtr  = (uint16_t) rdPtr;
   MEMIO_CONFIG->ethEnable = 1;  // Enabling the DMA will automatically reset the ethWrPtr.
 
   // Wait for data to be received, and print to the screen
   while (1)
   {
      uint8_t  *wrPtr;

      dummy_counter += 1;   // This generates a write to the main memory.
      wrPtr = (uint8_t *)(MEMIO_STATUS->ethWrPtr); // Check if data is present in buffer.
      if (rdPtr == wrPtr)
         continue;   // No? Then go back and wait for data

      // Skip past the length field
      rdPtr = ADD_PTR(rdPtr, 2);

      putx16(rdPtr);

      // Ok, we have received a packet. Now decode it.
      if (RD_BUF_OFFSET(rdPtr, 12) != 0x08)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 13) != 0x06)
         continue;

      cputs("ARP\n\r");

      // It is an ARP packet, now check the protocols
      if (RD_BUF_OFFSET(rdPtr, 14) != 0x00)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 15) != 0x01)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 16) != 0x08)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 17) != 0x00)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 18) != 0x06)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 19) != 0x04)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 20) != 0x00)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 21) != 0x01)
         continue;

      cputs("Request\n\r");

      // It is an ARP request, now check the IP address
      if (RD_BUF_OFFSET(rdPtr, 38) != 0xc0)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 39) != 0xa8)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 40) != 0x01)
         continue;
      if (RD_BUF_OFFSET(rdPtr, 41) != 0x4d)
         continue;

      cputs("Bingo!\n\r");
   }

} // end of main

