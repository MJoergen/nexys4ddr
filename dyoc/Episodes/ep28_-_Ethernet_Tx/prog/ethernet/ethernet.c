#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include "memorymap.h"

// This is the number of bytes to use for the entire receive buffer. It should be
// large enough to contain at least one complete frame, i.e. 1500 bytes.
#define BUF_SIZE 1540

// Write a single byte in hexadecimal.
void putx8(uint8_t x)
{
   static const char hex[16] = "0123456789ABCDEF";
   cputc(hex[(x>>4) & 0x0F]);
   cputc(hex[(x>>0) & 0x0F]);
}

// Write a 16-bit value in hexadecimal.
void putx16(uint16_t x)
{
   putx8((x>>8) & 0xFF);
   putx8((x>>0) & 0xFF);
}

// This variable is only used during simulation, to test the arbitration
// between CPU and Ethernet while writing to memory.
uint8_t dummy_counter = 0;

// Start of receive buffer
uint8_t *pBuf;

// First byte after the buffer. This is used in the macro RD_BUF().
uint8_t *pBufEnd;

// Current read pointer of the CPU
uint8_t *rdPtr;

// Pointer to end of last frame
uint8_t *endPtr;

// Length of current frame
uint16_t pktLen;

const uint8_t arpHeader[10]   = {0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01};
const uint8_t myMacAddress[6] = {0x70, 0x4D, 0x7B, 0x11, 0x22, 0x33};  // AsustekC
const uint8_t myIpAddress[4]  = {192, 168, 1, 77};

void main(void)
{
   // Allocate receive buffer. This will never be free'd.
   // Using malloc (rather than a globally allocated array) avoids a call to
   // memset generated by the compiler, thereby reducing simulation time.
   pBuf    = (uint8_t *) malloc(BUF_SIZE);
   pBufEnd = pBuf + BUF_SIZE;
   endPtr  = pBuf;

   // Configure Ethernet DMA
   MEMIO_CONFIG->ethEnable = 0;  // DMA must be disabled during configuration.
   MEMIO_CONFIG->ethStart  = (uint16_t) pBuf;
   MEMIO_CONFIG->ethEnd    = (uint16_t) pBufEnd;
   MEMIO_CONFIG->ethRdPtr  = (uint16_t) rdPtr;
   MEMIO_CONFIG->ethEnable = 1;  // Enabling the DMA will automatically reset the ethWrPtr.
 
   // Wait for data to be received, and print to the screen
   while (1)
   {
      dummy_counter += 1;   // This generates a write to the main memory.
      if (endPtr == (uint8_t *)(MEMIO_STATUS->ethWrPtr)) // Check if data is present in buffer.
         continue;   // No? Then go back and wait for data

      // Calculate length of frame
      pktLen = *((uint16_t *)endPtr);  // Read as little-endian.

      // Set read pointer to past the length field
      rdPtr = endPtr + 2;

      // Calculate new end of frame pointer.
      endPtr = endPtr + pktLen;

      // If remaining buffer cannot contain a complete frame,
      // then restart from the beginning
      if (endPtr+1500 > pBufEnd)
         endPtr = pBuf;

      putx16((uint16_t) rdPtr);

      if (memcmp(rdPtr+12, arpHeader, 10))
         continue;

      if (memcmp(rdPtr+38, myIpAddress, 4))
         continue;

      cputs("Bingo!\n\r");

      // Build new MAC header
      memcpy(rdPtr, rdPtr+6, 6);
      memcpy(rdPtr+6, myMacAddress, 6);

      // Build new ARP header
      rdPtr[21] = 2; // ARP Reply
      memcpy(rdPtr+32, rdPtr+22, 10); // Copy original senders MAC and IP address to the target.
      memcpy(rdPtr+22, myMacAddress, 6);
      memcpy(rdPtr+28, myIpAddress, 4);

      // Send reply
      MEMIO_CONFIG->ethTxPtr  = (uint16_t) rdPtr - 2;
      MEMIO_CONFIG->ethTxCtrl = 1;

      // Wait until frame has been consume by TxDMA.
      while (MEMIO_CONFIG->ethTxCtrl)
      {}

      // Release input buffer
      MEMIO_CONFIG->ethRdPtr = (uint16_t) endPtr;
   }

} // end of main

