#include <stdint.h>
#include <stdlib.h>
#include <conio.h>
#include "memorymap.h"


// This is a small demo program that waits in an infinite loop for incoming
// Ethernet frames. It prints the first 16 bytes of each frame.
// The purpose of this program is to test the synchronization between the CPU
// and the Rx DMA.


// This is the number of bytes to use for the entire receive buffer. It must be
// large enough to contain at least one complete frame, i.e. 1500 bytes.
#define BUF_SIZE 1600

// This variable is only used during simulation, to test the arbitration
// between CPU and Ethernet while writing to memory.
uint8_t dummy_counter;

// Start of receive buffer.
uint8_t *pBufStart;

// Current read pointer of the CPU
uint8_t *rdPtr;

// Length of current frame (including frame header)
uint16_t frmLen;

// Index variable
uint8_t  i;

// Used only in putx8.
const char hex[16] = "0123456789ABCDEF";

// Write a single byte in hexadecimal.
void putx8(uint8_t x)
{
   cputc(hex[x >> 4]);
   cputc(hex[x & 0x0F]);
}

// Write a 16-bit value in hexadecimal.
void putx16(uint16_t x)
{
   putx8(x >> 8);
   putx8(x & 0xFF);
}

void main(void)
{
   dummy_counter = 0;

   // Allocate receive buffer. This will never be free'd.
   // Using malloc (rather than a globally allocated array) avoids a call to
   // memset generated by the compiler, thereby reducing simulation time.
   pBufStart = (uint8_t *) malloc(BUF_SIZE);
   rdPtr     = pBufStart;

   // Configure Ethernet DMA
   MEMIO_CONFIG->ethRxdmaEnable = 0;  // DMA must be disabled during configuration.
   MEMIO_CONFIG->ethRxdmaPtr    = (uint16_t) pBufStart;
   MEMIO_CONFIG->ethRxdmaSize   = (uint16_t) BUF_SIZE;
   MEMIO_CONFIG->ethRxCpuPtr    = (uint16_t) rdPtr;
   MEMIO_CONFIG->ethRxdmaEnable = 1;  // Enabling the DMA will automatically reset the ethWrPtr.
 
   // Wait for data to be received, and print to the screen
   while (1)
   {
      // There must be room for a complete Ethernet frame in buffer.
      // If not, restart from beginning.

//      putx16((uint16_t)rdPtr);
//      cputs("-");

      while (rdPtr == (uint8_t *)(MEMIO_STATUS->ethRxbufPtr)) // Repeat until data is received
      {
         dummy_counter += 1;   // This generates a write to the main memory.
      }

      // The actual value of wrPtr cannot be trusted, because reading it takes two 
      // read operations, and the value of wrPtr may be updated in between the two
      // reads. Instead, we use the length given in the two-byte frame header.

      // Length of this frame in bytes.
      frmLen = *((uint16_t *) rdPtr);  // Read value as little-endian

//      // Show the pointer locations of the received Ethernet frame.
//      putx16((uint16_t)frmLen);
//      cputs(":");
//
//      // Show the 14 bytes MAC header.
//      for (i=2; i<16; ++i)
//      {
//         putx8(rdPtr[i]);
//      }

      // Advance the read pointer to start of next frame.
      rdPtr += frmLen;

//      cputs("\n\r");

      // Instruct DMA that CPU is finished with this frame.
      MEMIO_CONFIG->ethRxCpuPtr = (uint16_t) rdPtr;
   }

} // end of main

