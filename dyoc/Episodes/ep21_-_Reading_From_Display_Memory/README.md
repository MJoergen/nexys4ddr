# Design Your Own Computer
# Episode 21 : "Reading From Display Memory"

Welcome to "Design Your Own Computer".  In this episode
we'll make it possible for the CPU to read from the character
and colour memories.

To do this we need to introduce two new signals to the system
* mem\_wait
* cpu\_rden

## mem\_wait
The FPGA has built-in support for dual port memory, but alas, it looks like we
need three ports. That is because we have already used two ports for CPU write
and VGA read. The CPU read is supposed to happen on the falling clock edge,
which requires a third memory port. This is not possible, so we'll revert to
having the CPU read on the rising clock edge. This, however, inserts a delay of
one clock cycle each time the CPU performs a memory read, but only if it is
the character and colour memories.

To handle this extra address-dependent delay, we'll introduce a new mem\_wait
signal generated by the memory controller. The wait signal to the CPU,
cpu\_wait is then a logical OR of the previous signal sys\_wait and the new
signal mem\_wait, see lines 110-111 of comp.vhd . This way the CPU will only
proceed when the data from the memory is avaiable.

The mem\_wait signal is generated in lines 80-94 of mem/mem.vhd. Line 84 is the
main line, where CPU reads from either character or colour memories are to be
delayed. The remaining lines, 86-94 ensure that the mem\_wait signal is only
asserted for one clock cycle.

## cpu\_rden
The memory controller needs to know whether the CPU is performing a read or a
write (or possibly even no memory transaction at all). The CPU must therefore
provide a new signal cpu\_rden. This is because the mem\_wait signal should
not be asserted during a memory write cycle.

The cpu\_rden signal is determined in lines 407-420 of cpu/datapath.vhd. This
basically states that any memory transaction that is not a write must be a
read.



## CPU clock domain
We need the CPU to be able to read and write to and from the character
memory as well.
The Block RAM resources in the FPGA do indeed support Dual Port Mode, i.e.
with one write port (the CPU) and two read ports (the CPU and the VGA module).
However, since the CPU expects memory to be asynchronous, we have until now
made the CPU read on the *falling* clock edge. This won't work now, because
the FPGA considers this a different clock domain.

With the above description we habe a total of three clock domains: CPU rising
edge, CPU falling edge, and VGA rising edge. There are two approaches to
getting around this. One is to force the CPU and VGA to use the same clock ( as
they indeed to at the moment), thus equating the CPU rising edge and the VGA
rising edge.  The other approach is to tell the CPU to use synchronuous reads
when reading from the character and colour memmories. This latter is the
preferred approach as it is more flexible, allowing the CPU and the VGA modules
to have different clock speeds.  Furthermore, the support for synchronuous
reads is already implemented in the wait signal.

