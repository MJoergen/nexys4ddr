# CPU offloader
# Episode 10 : "Fact"

Welcome to this tenth episode of "CPU offloader", where we implement
the factoring of the outputs from the Continued Fraction algorothm.
The factoring is done in a number of steps.

## fact
The first step is to consider the product of many small primes.  For instance
the product of all primes from 2 to 59 gives the value 0x683ba8ff3e8b8a015e,
which conveniently fits into 72 bits.  Call this product P. So to determine
whether a given number Y factors completely over these small primes, just
calculate the gcd(Y, P). If this value is non-zero, then divide Y by this
number and repeat. If Y reaches the value 1, then the original value Y can be
completely factored over these small primes. Otherwise, if the gcd becomes 1
before Y reaches 1, then the original value Y can not be completely factored.
This may conveniently be described by the following pseudo-code:

```
do
   P = gcd(Y, P)
   Y = Y/P
while (P != 1)
```

So to perform the above algorithm, we need to calculate the gcd and to perform
a division.

### gcd
The original gcd algorithm described by Euclid involves division, and therefore
we could use the existing divmod module. However, I've chosen a different
algorithm with the expectation that it is faster and smaller. Basically the
algorithm works in the following steps:

1. Find the greatest common power of 2, by repeatedly dividing both numbers by
two, as long as they are both even.
2. Whenever one number is even it is divided by two.
3. If both numbers are odd, the smallest is subtracted from the largest.
4. Repeat steps 2 and 3 until the two numbers are equal. This will be the gcd.

### divexact
To calculate Y=Y/P we can make use of the fact that we know the remainder will
always by zero. In other words, the divison is always exact, and we can use
this knowledge to implement a faster division algorithm, where the result is
calculated from LSB to MSB, instead of the usual MSB to LSB.

## fact\_all
The fact module can factor a number over all primes from 2 to 59. However, by
repeatedly calling fact with larger primes, we can factor the number over a
larger range of primes. So the fact\_all module contains a list of
primes in lines 28-35.

## factors
The time required to reach a conclusion about the factorisation of the number Y
is quite long, much longer than it takes to generate the numbers Y. Therefore,
I've decided to instantiate a number of fact\_all modules in parallel, and
dispatch each computed Y to the next avaiable fact\_all module. This is all
done in the factors module.

The dispaching is basically a round-robin scheme, where a simple counter
indicates the next instance to receive a command.  If the fact\_all module
is available it gets the command and the instance counter is incremented with
wrap-around. Otherwise, the Y value is discarded. This all takes place in the
process in lines 62-97.

Once the fact\_all modules have calculated their result, they are gathered and
sent as a response. If two (or more) fact\_all modules deliver a result
simultaneously, one of the values are discarded. This is handled in the process
in lines 122-154.

## alg
The alg module simply instatiates the CF and Factors modules and connects them
together.

## Statistics
I've chosen to collect some statistics from the Factors module. Specifically,
I'm now counting the following:

* Number of (X, Y) pairs generated by the CF module.
* Number of (X, Y) pairs discarded, because all Factoring modules are busy.
* Number of (X, Y) pairs discarded, because two Factoring modules respond simultaneously.
* Number of completely factored (X, Y) pairs.
* Average number of clock cycles to factor a single Y value.

Furthermore, I've made it possible to control the number of primes to factor
over, as well as the number of factoring modules to use.

## Testing in simulation
We have added many small modules in this episode, and I've chosen to write a small
test bench for each of these small modules.

## Testing in hardware

