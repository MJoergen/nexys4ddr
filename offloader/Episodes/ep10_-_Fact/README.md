# CPU offloader
# Episode 10 : "Fact"

Welcome to this tenth episode of "CPU offloader", where we implement
the factoring of the outputs from the Continued Fraction algorothm.
The factoring is done in a number of steps.

## fact
The first step is to consider the product of many small primes.  For instance
the product of all primes from 2 to 59 gives the value 0x683ba8ff3e8b8a015e,
which conveniently fits into 72 bits.  Call this product P. So to determine
whether a given number Y factors completely over these small primes, just
calculate the gcd(Y, P). If this value is non-zero, then divide Y by this number
and repeat. If Y reaches the value 1, then the orioginal value Y can be
completely factored over these small primes. Otherwise, if the gcd becomes 1
before Y reaches 1, then the original value Y can not be completely factored.
This may conveniently be described by the following pseudo-code

```
do
   P = gcd(Y, P)
   Y = Y/P
while (P != 1)
```

So to perform the above algorithm, we need to calculate the gcd and to perform
a division.

### gcd
The original gcd algorithm described by Euclid involves division, and we could
use the existing divmod module. However, I've chosen a different algorithm with
the expectaion that it is faster and smaller. Basically the algorithm works in
two steps:

First it finds the greatest common power of 2, by repeatedly dividing both
numbers by two, if they are both even.

Second, whenever one number is even it is divided by two. Otherwise, both
numbers must be odd, and the smallest is subtracted from the largest.  If the
two numbers are equal, that will be the gcd.

### divexact
To calculate Y=Y/P we can make use of the fact that we know the remainder will
always by zero. In other words, the divison is always exact, and we can use
this knowledge to implement a faster division algorithm, where the result is
calculated from LSB to MSB, instead of the usual MSB to LSB.

## fact\_all
The fact module can factor a number over all primes from 2 to 59. However, by
repeatedly calling fact with larger primes, we can factor the number over a
larger range of primes. So the fact\_all module contains a list of
primes in lines 28-35.

## factors
The time required to reach a conclusion about the factorisation of the number Y
is quite long, much longer than it takes to generate the numbers Y. Therefore,
I've decided to instantiate a number of fact\_all module in parallel, and
dispatch each computer Y to the next avaiable fact\_all module. This is all
done in the factors module.

The dispaching is basically a round-robin scheme, where a simple counter
indicates the next instantiation to receive a command.  If the fact\_all module
is available it gets the command and the counter is incremented with
wrap-around. Otherwise, the Y value is discarded. This all takes place in the
process in lines 62-97.

Once the fact\_all modules have calculated their result, they are gathered and
sent as a response. If two (or more) fact\_all modules deliver a result
simultaneously, one of the values are discarded. This is handled in the process
in lines 122-154.

## alg
The alg module simply instatiates the CF and Factors modules and connects them
together.

## Statistics
I've chosen to collect some statistics from the Factors module. Specifically,
I'm now counting the following:

* Number of (X, Y) pairs generated by the CF module.
* Number of (X, Y) pairs discarded, because all Factoring modules are busy.
* Number of (X, Y) pairs discarded, because two Factoring modules respond simultaneously.
* Number of completely factored (X, Y) pairs.

Furthermore, I've made it possible to control the number of primes to factor
over, as well as the number of factoring modules to use.

## Testing in simulation
We have added many small modules in this episode, and I've chosen to write a small
test bench for each of these small modules. The makefile is common, so you'll manually
need to select the test bench to run. This is done by un-commenting the corresponding
name in lines 5-14 of math/Makefile.

## Testing in hardware

